// 객체지향 디자인 패턴의 핵심원리 #1. 공통성과 가변성의 분리
// => 변하지 않은 코드에서 변하는 것을 분리하는 것

// 변하는 것을 분리하는 2가지 기술
// 1. 변하는 것을 가상함수 분리
//    => "template method"
//    => 도형편집기 "draw()/draw_imp()"
// 
// 2. 변하는 것을 다른 클래스로 분리
// => 다른 클래스로 만든 정책을 어떻게 교체할것인가 ?
// 
// 2-1. 인터페이스 교체       : "strategy 패턴", 
//								Edit 예제의 IValidator
// 2-2. template 인자로 교체 : "policy base design", 
//								std::vector<int, debug_alloc<int>>

//----------------------------------------------------------
// 디자인 패턴의 핵심 개념 #2. 재귀적 포함(중첩)을 많이 사용합니다.

// A 는 B를 포함하지만 A 자신도 포함한다
// => A와 B는 공통의 기반 클래스 필요

// 포장지는 객체(사물)을 포장하지만, 포장된 상태를 다시 포장할수있다.
// => 객체와 포장지는 공통의 기반 클래스 필요

// 왜 공통의 기반 클래스를 만드는 가 ?
// (왜 재귀적인 포함을 사용하는가 ?)
// => 의도에 따라 패턴의 이름을 달라집니다

// Composite 패턴 : 복합객체 만들기(객체여러개를 포함해서 관리) - Tree 구조
// Decorator 패턴 : 객체에 동적인 기능 추가. 
//-------------------------------------------
// 객체지향 디자인 패턴의 핵심 개념 #3. 간접층(중간층)을 도입해서 문제를 해결하는것

// 왜 ?? 어떤 의도로 ?? 어떤 문제를 해결하려고 간접층을 도입하는가 ?

// 사용자 =============== stack ================> list
//								// 의도 : 인터페이스의 변경 
//								//		 list 를 다른 것(stack)처럼 보이게 하려는 의도
//								// adapter
// 사용자 =============== TCPServer ============> Socket, IPAddress,...
//								// 의도 : 여러클래스의 복잡한 작업을 쉽게 사용하기 위한
//								//        하나의 단순한 인터페이스
//								// facade
// 
// 사용자 =============== MP3  =================> IMP3
//								// 의도 : 구현부와 추상(서비스계층)의 상호 독립된 update
//								// bridge
// 
// 사용자 =============== Calc =================> CalcServer
//								// 의도 : 다양한 목적을 가진 "대신 사용하는 도구"를 만든것
//								// proxy
//-------------------------------------------------------------------
// 디자인 패턴의 핵심 #4. 객체를 만드는 다양한 방법을 알아 두세요

// 
// 1. Rect rc;			// stack 변수
						// => 수명이 정해져 있다.

// 2. Rect* rc = new Rect;	// 가장 자유 로운 방법
							// => 가장 자유로운것이 가장 좋은 것은 아니다

// 위 2가지 방법 외에도 아래의 방법들도 항상 고려해 보세요
// 3. Rect* rc = Rect::create();  // static 멤버 함수(static factory method)
									// 1. 오직 한개만 만들수도 있다 - singleton
									// 2. 객체를 공유할수 도 있다	- flyweight	
									// 3. 가독성도 좋다 Rect::redRect()
									// 4. 생성함수를 자료구조에 보관도 가능.

// 4. Rect* rc = sample->clone();	// prototype

// 4. Rect* rc = factory.create();	// factory

