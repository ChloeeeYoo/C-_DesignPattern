// 객체지향 디자인 패턴의 핵심원리 #1. 공통성과 가변성의 분리
// => 변하지 않은 코드에서 변하는 것을 분리하는 것

// 변하는 것을 분리하는 2가지 기술
// 1. 변하는 것을 가상함수 분리
//    => "template method"
//    => 도형편집기 "draw()/draw_imp()"
// 
// 2. 변하는 것을 다른 클래스로 분리
// => 다른 클래스로 만든 정책을 어떻게 교체할것인가 ?
// 
// 2-1. 인터페이스 교체       : "strategy 패턴", 
//								Edit 예제의 IValidator
// 2-2. template 인자로 교체 : "policy base design", 
//								std::vector<int, debug_alloc<int>>

//----------------------------------------------------------
// 디자인 패턴의 핵심 개념 #2. 재귀적 포함(중첩)을 많이 사용합니다.

// A 는 B를 포함하지만 A 자신도 포함한다
// => A와 B는 공통의 기반 클래스 필요

// 포장지는 객체(사물)을 포장하지만, 포장된 상태를 다시 포장할수있다.
// => 객체와 포장지는 공통의 기반 클래스 필요

// 왜 공통의 기반 클래스를 만드는 가 ?
// (왜 재귀적인 포함을 사용하는가 ?)
// => 의도에 따라 패턴의 이름을 달라집니다

// Composite 패턴 : 복합객체 만들기(객체여러개를 포함해서 관리) - Tree 구조
// Decorator 패턴 : 객체에 동적인 기능 추가. 
//-------------------------------------------
